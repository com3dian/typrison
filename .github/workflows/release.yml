name: Build Release Packages

on:
  release:
    types: [created, published]
  workflow_dispatch: # Allows manual trigger for testing
    inputs:
      version:
        description: 'Version to build (optional, uses tag if not provided)'
        required: false

jobs:
  create-release:
    runs-on: ubuntu-latest
    if: github.event_name != 'release'
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Get version
      id: get_version
      run: |
        VERSION="${GITHUB_REF#refs/tags/}"
        if [ -z "$VERSION" ] || [ "$VERSION" == "$GITHUB_REF" ]; then
          VERSION="${{ github.event.inputs.version || 'dev' }}"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
    
    - name: Create release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.get_version.outputs.version }}
        release_name: "TypistPrison ${{ steps.get_version.outputs.version }}"
        body: "Automated release build"
        draft: false
        prerelease: false

  build-macos:
    runs-on: macos-latest
    continue-on-error: false
    needs: [create-release]
    if: always() && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Qt
      uses: jurplel/install-qt-action@v4
      id: install-qt
      with:
        version: '6.8.0'
        host: 'mac'
        target: 'desktop'
        arch: 'clang_64'
        cache: true
    
    - name: Verify Qt installation
      run: |
        echo "Checking Qt installation..."
        echo "Qt6_DIR: $Qt6_DIR"
        echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
        if [ -n "$Qt6_DIR" ] && [ -d "$Qt6_DIR" ]; then
          echo "Qt6_DIR exists: $Qt6_DIR"
          ls -la "$Qt6_DIR" || true
        fi
        if [ -n "$CMAKE_PREFIX_PATH" ]; then
          echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
          find "$CMAKE_PREFIX_PATH" -name "Qt6Config.cmake" 2>/dev/null | head -1 || echo "Qt6Config.cmake not found in CMAKE_PREFIX_PATH"
        fi
    
    - name: Configure CMake
      run: |
        cd typistprison
        mkdir -p build-release
        cd build-release
        echo "Environment variables:"
        env | grep -i qt || true
        echo "Qt6_DIR: $Qt6_DIR"
        echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
        echo "Running CMake configuration..."
        
        # Build CMake command
        CMAKE_CMD="cmake -DCMAKE_BUILD_TYPE=Release -G \"Unix Makefiles\""
        
        # Add Qt path if available
        if [ -n "$Qt6_DIR" ]; then
          CMAKE_CMD="$CMAKE_CMD -DQt6_DIR=\"$Qt6_DIR\""
          echo "Using Qt6_DIR: $Qt6_DIR"
        elif [ -n "$CMAKE_PREFIX_PATH" ]; then
          CMAKE_CMD="$CMAKE_CMD -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH\""
          echo "Using CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
        else
          echo "Warning: No Qt path found in environment!"
        fi
        
        CMAKE_CMD="$CMAKE_CMD .."
        echo "CMake command: $CMAKE_CMD"
        
        # Run CMake and capture output
        eval $CMAKE_CMD 2>&1 | tee cmake_output.log
        CMAKE_EXIT_CODE=${PIPESTATUS[0]}
        
        if [ $CMAKE_EXIT_CODE -ne 0 ]; then
          echo "ERROR: CMake configuration failed with exit code $CMAKE_EXIT_CODE"
          cat cmake_output.log
          exit 1
        fi
        
        echo "CMake configuration completed. Checking for Makefile..."
        if [ ! -f "Makefile" ]; then
          echo "ERROR: Makefile not found after CMake configuration!"
          cat cmake_output.log
          exit 1
        fi
        echo "Makefile found successfully!"
    
    - name: Build
      run: |
        cd typistprison/build-release
        if [ ! -f "Makefile" ]; then
          echo "Error: No Makefile found! CMake configuration may have failed."
          exit 1
        fi
        cmake --build . --config Release -j$(sysctl -n hw.ncpu)
    
    - name: Find .app bundle
      id: find_app
      run: |
        APP_PATH=$(find typistprison/build-release -name "*.app" -type d | head -n 1)
        echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT
        echo "Found app at: $APP_PATH"
    
    - name: Deploy Qt dependencies and create DMG
      run: |
        APP_PATH="${{ steps.find_app.outputs.app_path }}"
        # Deploy Qt dependencies into the app bundle
        macdeployqt "$APP_PATH" -always-overwrite -verbose=2
        # Create DMG
        macdeployqt "$APP_PATH" -dmg -always-overwrite
        DMG_PATH="${APP_PATH%.app}.dmg"
        echo "DMG created at: $DMG_PATH"
        ls -lh "$(dirname $DMG_PATH)"
        
        # Verify Qt libraries are bundled
        if [ -d "$APP_PATH/Contents/Frameworks" ]; then
          echo "Qt frameworks bundled:"
          ls -lh "$APP_PATH/Contents/Frameworks" | head -10
        fi
    
    - name: Rename DMG with version
      id: rename_dmg
      run: |
        APP_PATH="${{ steps.find_app.outputs.app_path }}"
        DMG_PATH="${APP_PATH%.app}.dmg"
        VERSION="${GITHUB_REF#refs/tags/}"
        if [ -z "$VERSION" ] || [ "$VERSION" == "$GITHUB_REF" ]; then
          VERSION="dev"
        fi
        NEW_NAME="TypistPrison-${VERSION}-macOS.dmg"
        mv "$DMG_PATH" "typistprison/build-release/$NEW_NAME"
        echo "dmg_name=$NEW_NAME" >> $GITHUB_OUTPUT
        echo "dmg_path=typistprison/build-release/$NEW_NAME" >> $GITHUB_OUTPUT
    
    - name: Upload DMG artifact
      uses: actions/upload-artifact@v4
      with:
        name: macos-dmg
        path: ${{ steps.rename_dmg.outputs.dmg_path }}
    
    - name: Debug release info
      if: github.event_name == 'release'
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Release upload URL: ${{ github.event.release.upload_url }}"
        echo "DMG path: ${{ steps.rename_dmg.outputs.dmg_path }}"
        echo "DMG name: ${{ steps.rename_dmg.outputs.dmg_name }}"
        if [ -f "${{ steps.rename_dmg.outputs.dmg_path }}" ]; then
          echo "DMG file exists!"
          ls -lh "${{ steps.rename_dmg.outputs.dmg_path }}"
        else
          echo "ERROR: DMG file not found!"
        fi
    
    - name: Upload DMG to release
      if: github.event_name == 'release' && steps.rename_dmg.outputs.dmg_path != '' && github.event.release.upload_url != ''
      run: |
        echo "Uploading DMG to release..."
        echo "File path: ${{ steps.rename_dmg.outputs.dmg_path }}"
        echo "File name: ${{ steps.rename_dmg.outputs.dmg_name }}"
        echo "Upload URL: ${{ github.event.release.upload_url }}"
        if [ ! -f "${{ steps.rename_dmg.outputs.dmg_path }}" ]; then
          echo "ERROR: DMG file does not exist!"
          exit 1
        fi
        ls -lh "${{ steps.rename_dmg.outputs.dmg_path }}"
      continue-on-error: false
    
    - name: Upload DMG to release (action)
      if: steps.rename_dmg.outputs.dmg_path != ''
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url || needs.create-release.outputs.upload_url }}
        asset_path: ${{ steps.rename_dmg.outputs.dmg_path }}
        asset_name: ${{ steps.rename_dmg.outputs.dmg_name }}
        asset_content_type: application/x-apple-diskimage

  build-windows:
    runs-on: windows-latest
    continue-on-error: false
    needs: [create-release]
    if: always() && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install Qt
      uses: jurplel/install-qt-action@v4
      id: install-qt
      with:
        version: '6.5.3'
        host: 'windows'
        target: 'desktop'
        arch: 'win64_msvc2019_64'
        cache: false
    
    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64
    
    - name: Install Ninja
      run: choco install ninja -y
    
    - name: Configure CMake
      shell: bash
      run: |
        cd typistprison
        mkdir -p build-release
        cd build-release
        echo "Environment variables:"
        env | grep -i qt || true
        echo "Qt6_DIR: $Qt6_DIR"
        echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
        
        # Build CMake command
        CMAKE_CMD="cmake -DCMAKE_BUILD_TYPE=Release -G \"Ninja\""
        
        # Add Qt path if available
        if [ -n "$Qt6_DIR" ]; then
          CMAKE_CMD="$CMAKE_CMD -DQt6_DIR=\"$Qt6_DIR\""
          echo "Using Qt6_DIR: $Qt6_DIR"
        elif [ -n "$CMAKE_PREFIX_PATH" ]; then
          CMAKE_CMD="$CMAKE_CMD -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH\""
          echo "Using CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
        fi
        
        CMAKE_CMD="$CMAKE_CMD .."
        echo "CMake command: $CMAKE_CMD"
        
        # Run CMake
        eval $CMAKE_CMD 2>&1 | tee cmake_output.log
        CMAKE_EXIT_CODE=${PIPESTATUS[0]}
        
        if [ $CMAKE_EXIT_CODE -ne 0 ]; then
          echo "ERROR: CMake configuration failed with exit code $CMAKE_EXIT_CODE"
          cat cmake_output.log
          exit 1
        fi
        
        echo "CMake configuration completed. Checking for build files..."
        if [ ! -f "build.ninja" ]; then
          echo "ERROR: build.ninja not found after CMake configuration!"
          cat cmake_output.log
          exit 1
        fi
        echo "build.ninja found successfully!"
    
    - name: Build
      shell: bash
      run: |
        cd typistprison/build-release
        if [ ! -f "build.ninja" ]; then
          echo "Error: No build.ninja found! CMake configuration may have failed."
          exit 1
        fi
        cmake --build . --config Release
    
    - name: Find EXE
      id: find_exe
      shell: bash
      run: |
        echo "Searching for executable..."
        echo "All .exe files found:"
        find typistprison/build-release -name "*.exe" -type f 2>/dev/null
        
        # Try to find the actual application executable (not CMake test files)
        EXE_PATH=$(find typistprison/build-release -name "typistprison.exe" -type f 2>/dev/null | grep -v "CMakeFiles" | head -n 1)
        if [ -z "$EXE_PATH" ]; then
          echo "Trying TypistPrison.exe..."
          EXE_PATH=$(find typistprison/build-release -name "TypistPrison.exe" -type f 2>/dev/null | grep -v "CMakeFiles" | head -n 1)
        fi
        if [ -z "$EXE_PATH" ]; then
          echo "Trying any .exe excluding CMakeFiles..."
          EXE_PATH=$(find typistprison/build-release -name "*.exe" -type f 2>/dev/null | grep -v "CMakeFiles" | grep -v "CompilerId" | head -n 1)
        fi
        
        if [ -z "$EXE_PATH" ] || [ ! -f "$EXE_PATH" ]; then
          echo "ERROR: Application executable not found!"
          echo "Build directory contents:"
          ls -la typistprison/build-release/ || true
          find typistprison/build-release -type f -name "*.exe" 2>/dev/null
          exit 1
        fi
        
        echo "exe_path=$EXE_PATH" >> $GITHUB_OUTPUT
        echo "Found executable at: $EXE_PATH"
        ls -lh "$EXE_PATH"
        EXE_DIR=$(dirname "$EXE_PATH")
        echo "exe_dir=$EXE_DIR" >> $GITHUB_OUTPUT
    
    - name: Deploy Qt dependencies
      shell: bash
      run: |
        EXE_PATH="${{ steps.find_exe.outputs.exe_path }}"
        EXE_DIR="${{ steps.find_exe.outputs.exe_dir }}"
        echo "Deploying Qt dependencies on Windows..."
        echo "Executable path: $EXE_PATH"
        echo "Executable dir: $EXE_DIR"
        echo "Qt-related environment variables:"
        env | grep -i qt || true
        echo "PATH: $PATH"

        # Use windeployqt to bundle all Qt dependencies.
        # jurplel/install-qt-action adds the Qt bin directory (containing windeployqt) to PATH.
        # First try with compiler runtime, then fall back to a simpler invocation.
        windeployqt --release --compiler-runtime "$EXE_PATH" || \
        windeployqt --release "$EXE_PATH" || {
          echo "ERROR: windeployqt failed to run or was not found in PATH"
          which windeployqt || echo "windeployqt not found in PATH"
          exit 1
        }
        
        echo "Deployed files:"
        ls -lh "$EXE_DIR" | head -30
        
        # Verify Qt DLLs are present
        if ls "$EXE_DIR"/*.dll 1> /dev/null 2>&1; then
          echo "Qt DLLs found:"
          ls -lh "$EXE_DIR"/*.dll | head -10
        else
          echo "Warning: No DLLs found in deployment directory"
        fi
    
    - name: Create distributable package
      id: create_package
      shell: bash
      run: |
        VERSION="${GITHUB_REF#refs/tags/}"
        if [ -z "$VERSION" ] || [ "$VERSION" == "$GITHUB_REF" ]; then
          VERSION="dev"
        fi
        PACKAGE_NAME="TypistPrison-${VERSION}-Windows"
        PACKAGE_DIR="typistprison/build-release/$PACKAGE_NAME"
        EXE_DIR="${{ steps.find_exe.outputs.exe_dir }}"

        mkdir -p "$PACKAGE_DIR"

        echo "EXE_DIR: $EXE_DIR"
        echo "PACKAGE_DIR: $PACKAGE_DIR"

        # Copy everything from EXE_DIR into PACKAGE_DIR, but avoid copying PACKAGE_DIR into itself
        echo "Copying files from EXE_DIR into PACKAGE_DIR (excluding PACKAGE_DIR itself)..."
        for ITEM in "$EXE_DIR"/*; do
          # Skip if source doesn't exist (globbing with no matches)
          [ -e "$ITEM" ] || continue
          # Skip the package directory itself if it lives inside EXE_DIR
          if [ "$ITEM" = "$PACKAGE_DIR" ]; then
            echo "Skipping self directory: $ITEM"
            continue
          fi
          echo "Copying: $ITEM -> $PACKAGE_DIR/"
          cp -r "$ITEM" "$PACKAGE_DIR/"
        done
        
        # Create zip
        cd typistprison/build-release
        7z a "${PACKAGE_NAME}.zip" "$PACKAGE_NAME"
        
        echo "package_name=${PACKAGE_NAME}.zip" >> $GITHUB_OUTPUT
        echo "package_path=typistprison/build-release/${PACKAGE_NAME}.zip" >> $GITHUB_OUTPUT

    - name: Create self-extracting EXE (portable)
      id: create_sfx
      shell: pwsh
      run: |
        $ref = $env:GITHUB_REF
        $version = $ref -replace '^refs/tags/',''
        if ([string]::IsNullOrEmpty($version) -or $version -eq $ref) { $version = 'dev' }

        $packageName = "TypistPrison-$version-Windows"
        $buildRoot   = "typistprison/build-release"
        $packageDir  = Join-Path $buildRoot $packageName
        $sfxName     = "TypistPrison-$version-Windows-portable.exe"
        $sfxPath     = Join-Path $buildRoot $sfxName

        Write-Host "Creating self-extracting EXE: $sfxPath"
        Write-Host "Package directory: $packageDir"

        if (-not (Test-Path $packageDir)) {
          Write-Error "Package directory not found: $packageDir"
          exit 1
        }

        # Ensure 7-Zip is available (for 7z.sfx and 7z.exe)
        choco install 7zip -y | Out-Null

        $sevenZipPath = Join-Path $env:ProgramFiles '7-Zip'
        $sevenZipExe  = Join-Path $sevenZipPath '7z.exe'
        $sfxStub      = Join-Path $sevenZipPath '7z.sfx'

        if (-not (Test-Path $sevenZipExe)) {
          Write-Error "7z.exe not found at $sevenZipExe"
          exit 1
        }
        if (-not (Test-Path $sfxStub)) {
          Write-Error "7z.sfx not found at $sfxStub"
          exit 1
        }

        # Create 7z payload containing the contents of the package directory
        # Convert to absolute path to avoid path resolution issues
        $payloadPath = [System.IO.Path]::GetFullPath((Join-Path $buildRoot 'payload.7z'))
        if (Test-Path $payloadPath) { Remove-Item $payloadPath -Force }
        
        Write-Host "Creating payload archive at: $payloadPath"
        Push-Location $packageDir
        $result = & $sevenZipExe a -t7z $payloadPath * 2>&1
        $result | Write-Host
        Pop-Location

        # Wait a moment for file system to sync, then check with retry
        $maxRetries = 5
        $retryCount = 0
        $fileExists = $false
        
        while ($retryCount -lt $maxRetries -and -not $fileExists) {
          Start-Sleep -Milliseconds 200
          $fileExists = Test-Path $payloadPath
          if (-not $fileExists) {
            $retryCount++
            Write-Host "Waiting for payload archive... (attempt $retryCount/$maxRetries)"
          }
        }

        if (-not $fileExists) {
          Write-Error "Failed to create payload archive at $payloadPath"
          Write-Host "Current location: $(Get-Location)"
          Write-Host "Build root exists: $(Test-Path $buildRoot)"
          Write-Host "Files in build root:"
          if (Test-Path $buildRoot) {
            Get-ChildItem $buildRoot | Select-Object -First 10 | Format-Table
          }
          Write-Host "Looking for payload.7z in build root..."
          Get-ChildItem $buildRoot -Filter 'payload.7z' -ErrorAction SilentlyContinue | Format-Table
          exit 1
        }
        
        Write-Host "Payload archive created successfully at $payloadPath"
        $payloadInfo = Get-Item $payloadPath
        Write-Host "Payload size: $($payloadInfo.Length) bytes ($([math]::Round($payloadInfo.Length / 1MB, 2)) MB)"

        # Create SFX configuration
        $configPath = Join-Path $buildRoot 'sfx_config.txt'
        @(
          ';!@Install@!UTF-8!'
          'Title=TypistPrison'
          'RunProgram=TypistPrison.exe'
          ';!@InstallEnd@!'
        ) | Set-Content -Encoding UTF8 $configPath

        # Concatenate stub + config + payload into final EXE
        $stubBytes    = [System.IO.File]::ReadAllBytes($sfxStub)
        $cfgBytes     = [System.IO.File]::ReadAllBytes($configPath)
        $payloadBytes = [System.IO.File]::ReadAllBytes($payloadPath)

        $allBytes = New-Object byte[] ($stubBytes.Length + $cfgBytes.Length + $payloadBytes.Length)
        [Array]::Copy($stubBytes,    0, $allBytes, 0,                         $stubBytes.Length)
        [Array]::Copy($cfgBytes,     0, $allBytes, $stubBytes.Length,         $cfgBytes.Length)
        [Array]::Copy($payloadBytes, 0, $allBytes, $stubBytes.Length + $cfgBytes.Length, $payloadBytes.Length)

        [System.IO.File]::WriteAllBytes($sfxPath, $allBytes)

        if (-not (Test-Path $sfxPath)) {
          Write-Error "Failed to create self-extracting EXE at $sfxPath"
          exit 1
        }

        Write-Host "Self-extracting EXE created at $sfxPath"

        # Expose outputs for later steps
        "sfx_name=$sfxName" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        "sfx_path=$sfxPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
    
    - name: Upload Windows package artifact
      uses: actions/upload-artifact@v4
      with:
        name: windows-exe
        path: |
          ${{ steps.create_package.outputs.package_path }}
          ${{ steps.create_sfx.outputs.sfx_path }}
    
    - name: Debug Windows release upload
      if: github.event_name == 'release'
      shell: bash
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Release upload URL: ${{ github.event.release.upload_url }}"
        echo "Package path: ${{ steps.create_package.outputs.package_path }}"
        echo "Package name: ${{ steps.create_package.outputs.package_name }}"
        if [ -f "${{ steps.create_package.outputs.package_path }}" ]; then
          echo "Package file exists!"
          ls -lh "${{ steps.create_package.outputs.package_path }}"
        else
          echo "ERROR: Package file not found!"
        fi
    
    - name: Upload package to release
      if: steps.create_package.outputs.package_path != ''
      continue-on-error: false
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url || needs.create-release.outputs.upload_url }}
        asset_path: ${{ steps.create_package.outputs.package_path }}
        asset_name: ${{ steps.create_package.outputs.package_name }}
        asset_content_type: application/zip

    - name: Upload portable EXE to release
      if: steps.create_sfx.outputs.sfx_path != ''
      continue-on-error: false
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url || needs.create-release.outputs.upload_url }}
        asset_path: ${{ steps.create_sfx.outputs.sfx_path }}
        asset_name: ${{ steps.create_sfx.outputs.sfx_name }}
        asset_content_type: application/vnd.microsoft.portable-executable

  build-linux:
    runs-on: ubuntu-latest
    continue-on-error: false
    needs: [create-release]
    if: always() && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          ninja-build \
          libgl1-mesa-dev \
          libglib2.0-dev \
          libxkbcommon-x11-0 \
          libxkbcommon-dev
    
    - name: Install Qt
      uses: jurplel/install-qt-action@v4
      id: install-qt
      with:
        version: '6.5.3'
        host: 'linux'
        target: 'desktop'
        arch: 'gcc_64'
        cache: false
    
    - name: Capture Qt installation path
      id: qt_path
      run: |
        QT_BASE=""
        
        # Try to get Qt path from environment variables
        if [ -n "$Qt6_DIR" ] && [ -d "$Qt6_DIR" ]; then
          QT_BASE=$(dirname "$Qt6_DIR")
          echo "Found Qt via Qt6_DIR: $QT_BASE"
        elif [ -n "$CMAKE_PREFIX_PATH" ] && [ -d "$CMAKE_PREFIX_PATH" ]; then
          QT_BASE="$CMAKE_PREFIX_PATH"
          echo "Found Qt via CMAKE_PREFIX_PATH: $QT_BASE"
        else
          # Try to find qmake
          if command -v qmake &> /dev/null; then
            QMAKE_PATH=$(which qmake)
            QT_BASE=$(dirname $(dirname "$QMAKE_PATH"))
            echo "Found Qt via qmake: $QT_BASE"
          else
            # Try common locations
            for path in "$HOME/Qt/6.5.3/gcc_64" "/opt/qt/6.5.3/gcc_64"; do
              if [ -d "$path" ] && [ -f "$path/bin/qmake" ]; then
                QT_BASE="$path"
                echo "Found Qt in: $QT_BASE"
                break
              fi
            done
          fi
        fi
        
        # Verify we found Qt
        if [ -z "$QT_BASE" ] || [ ! -d "$QT_BASE" ]; then
          echo "ERROR: Could not determine Qt installation path"
          echo "Environment:"
          env | grep -i qt || true
          echo "Qt6_DIR: $Qt6_DIR"
          echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
          exit 1
        fi
        
        # Verify Qt installation has required directories
        if [ ! -d "$QT_BASE/lib" ]; then
          echo "ERROR: Qt installation at $QT_BASE does not have lib directory"
          ls -la "$QT_BASE" || true
          exit 1
        fi
        
        # Save to output
        echo "qt_base=$QT_BASE" >> $GITHUB_OUTPUT
        echo "Qt installation path saved: $QT_BASE"
    
    - name: Configure CMake
      run: |
        cd typistprison
        mkdir -p build-release
        cd build-release
        echo "Environment variables:"
        env | grep -i qt || true
        echo "Qt6_DIR: $Qt6_DIR"
        echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
        
        # Build CMake command
        CMAKE_CMD="cmake -DCMAKE_BUILD_TYPE=Release -G \"Ninja\""
        
        # Add Qt path if available
        if [ -n "$Qt6_DIR" ]; then
          CMAKE_CMD="$CMAKE_CMD -DQt6_DIR=\"$Qt6_DIR\""
          echo "Using Qt6_DIR: $Qt6_DIR"
        elif [ -n "$CMAKE_PREFIX_PATH" ]; then
          CMAKE_CMD="$CMAKE_CMD -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH\""
          echo "Using CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
        else
          echo "Warning: No Qt path found in environment!"
        fi
        
        CMAKE_CMD="$CMAKE_CMD .."
        echo "CMake command: $CMAKE_CMD"
        
        # Run CMake and capture output
        eval $CMAKE_CMD 2>&1 | tee cmake_output.log
        CMAKE_EXIT_CODE=${PIPESTATUS[0]}
        
        if [ $CMAKE_EXIT_CODE -ne 0 ]; then
          echo "ERROR: CMake configuration failed with exit code $CMAKE_EXIT_CODE"
          cat cmake_output.log
          exit 1
        fi
        
        echo "CMake configuration completed. Checking for build files..."
        if [ ! -f "build.ninja" ]; then
          echo "ERROR: build.ninja not found after CMake configuration!"
          cat cmake_output.log
          exit 1
        fi
        echo "build.ninja found successfully!"
    
    - name: Build
      run: |
        cd typistprison/build-release
        if [ ! -f "build.ninja" ]; then
          echo "Error: No build.ninja found! CMake configuration may have failed."
          exit 1
        fi
        cmake --build . --config Release
        echo "Build completed. Listing build directory:"
        find . -type f -executable 2>/dev/null | head -20
        ls -la . || true
    
    - name: Find executable
      id: find_exe
      run: |
        echo "Searching for executable in typistprison/build-release..."
        echo "All files in build directory:"
        find typistprison/build-release -type f 2>/dev/null | head -30
        echo ""
        echo "All executables:"
        find typistprison/build-release -type f -executable 2>/dev/null | head -10
        echo ""
        
        # Try to find the executable with various names
        EXE_PATH=$(find typistprison/build-release -name "typistprison" -type f -executable 2>/dev/null | head -n 1)
        if [ -z "$EXE_PATH" ]; then
          echo "Executable 'typistprison' not found, trying 'TypistPrison'..."
          EXE_PATH=$(find typistprison/build-release -name "TypistPrison" -type f -executable 2>/dev/null | head -n 1)
        fi
        if [ -z "$EXE_PATH" ]; then
          echo "Trying any executable file (excluding libraries)..."
          EXE_PATH=$(find typistprison/build-release -type f -executable 2>/dev/null | grep -v "\.so" | grep -v "\.a" | grep -v "CMakeFiles" | head -n 1)
        fi
        
        if [ -z "$EXE_PATH" ] || [ ! -f "$EXE_PATH" ]; then
          echo "ERROR: No executable found!"
          echo "Build directory structure:"
          ls -laR typistprison/build-release/ 2>/dev/null | head -50
          exit 1
        fi
        
        echo "exe_path=$EXE_PATH" >> $GITHUB_OUTPUT
        echo "Found executable at: $EXE_PATH"
        ls -lh "$EXE_PATH"
        file "$EXE_PATH"
        EXE_DIR=$(dirname "$EXE_PATH")
        echo "exe_dir=$EXE_DIR" >> $GITHUB_OUTPUT
    
    - name: Install deployment tools
      run: |
        sudo apt-get update
        sudo apt-get install -y patchelf file fuse libfuse2 imagemagick
    
    - name: Deploy Qt dependencies
      run: |
        EXE_PATH="${{ steps.find_exe.outputs.exe_path }}"
        EXE_DIR="${{ steps.find_exe.outputs.exe_dir }}"
        QT_BASE="${{ steps.qt_path.outputs.qt_base }}"
        
        # Verify Qt path was captured
        if [ -z "$QT_BASE" ] || [ ! -d "$QT_BASE" ]; then
          echo "ERROR: Qt installation path not found or invalid"
          echo "Qt path from step output: $QT_BASE"
          echo "Trying to find Qt again..."
          
          # Fallback: try to find Qt again
          if [ -n "$Qt6_DIR" ] && [ -d "$Qt6_DIR" ]; then
            QT_BASE=$(dirname "$Qt6_DIR")
          elif [ -n "$CMAKE_PREFIX_PATH" ] && [ -d "$CMAKE_PREFIX_PATH" ]; then
            QT_BASE="$CMAKE_PREFIX_PATH"
          elif command -v qmake &> /dev/null; then
            QMAKE_PATH=$(which qmake)
            QT_BASE=$(dirname $(dirname "$QMAKE_PATH"))
          fi
          
          if [ -z "$QT_BASE" ] || [ ! -d "$QT_BASE" ]; then
            echo "ERROR: Cannot find Qt installation path"
            exit 1
          fi
        fi
        
        echo "Using Qt installation at: $QT_BASE"
        
        # Verify Qt installation has required directories
        if [ ! -d "$QT_BASE/lib" ]; then
          echo "ERROR: Qt installation at $QT_BASE does not have lib directory"
          ls -la "$QT_BASE" || true
          exit 1
        fi
        
        echo "Qt base path: $QT_BASE"
        echo "Executable: $EXE_PATH"
        echo "Executable dir: $EXE_DIR"
        
        cd "$EXE_DIR"
        mkdir -p lib plugins translations
        
        # Copy all Qt libraries from Qt installation
        if [ -d "$QT_BASE/lib" ]; then
          echo "Copying Qt libraries from installation..."
          find "$QT_BASE/lib" -name "libQt*.so*" -type f -exec cp -v {} lib/ \; 2>/dev/null || true
        fi
        
        # Copy Qt plugins
        if [ -d "$QT_BASE/plugins" ]; then
          echo "Copying Qt plugins..."
          cp -r "$QT_BASE/plugins"/* plugins/ 2>/dev/null || true
        fi
        
        # Copy Qt translations
        if [ -d "$QT_BASE/translations" ]; then
          echo "Copying Qt translations..."
          cp -r "$QT_BASE/translations"/* translations/ 2>/dev/null || true
        fi
        
        # Find and copy all non-system dependencies of the executable
        echo "Finding and copying runtime dependencies..."
        DEPS_FILE=$(mktemp)
        ldd "$EXE_PATH" 2>/dev/null | grep -v "not found" | awk '{print $3}' > "$DEPS_FILE"
        
        # Also get dependencies from Qt libraries we just copied
        find lib -name "*.so*" -type f -exec ldd {} \; 2>/dev/null | grep -v "not found" | awk '{print $3}' >> "$DEPS_FILE"
        
        # Copy dependencies, prioritizing Qt and ICU libraries
        while IFS= read -r lib_path; do
          if [ -z "$lib_path" ] || [ ! -f "$lib_path" ]; then
            continue
          fi
          
          lib_name=$(basename "$lib_path")
          
          # Skip if already copied
          if [ -f "lib/$lib_name" ]; then
            continue
          fi
          
          # Copy Qt, ICU, and other important libraries
          # Skip most system libraries but include Qt/ICU even if in system paths
          if [[ "$lib_name" == libQt* ]] || [[ "$lib_name" == libicu* ]] || \
             [[ "$lib_name" == libxcb* ]] || [[ "$lib_name" == libX11* ]] || \
             [[ "$lib_name" == libXext* ]] || [[ "$lib_name" == libXrender* ]] || \
             [[ "$lib_name" == libXfixes* ]] || [[ "$lib_name" == libXau* ]] || \
             [[ "$lib_name" == libXdmcp* ]] || [[ "$lib_name" == libxkbcommon* ]] || \
             [[ "$lib_name" == libfontconfig* ]] || [[ "$lib_name" == libfreetype* ]] || \
             [[ "$lib_name" == libpng* ]] || [[ "$lib_name" == libjpeg* ]] || \
             [[ "$lib_name" == libz.so* ]] || [[ "$lib_name" == libharfbuzz* ]] || \
             [[ "$lib_name" == libdouble-conversion* ]] || [[ "$lib_name" == libpcre2* ]] || \
             [[ "$lib_name" == libmd4c* ]] || [[ "$lib_name" == libmd4c.so* ]]; then
            cp "$lib_path" "lib/$lib_name" 2>/dev/null && echo "Copied: $lib_name" || true
          elif [[ "$lib_path" != /lib/* ]] && [[ "$lib_path" != /lib64/* ]] && \
               [[ "$lib_path" != /usr/lib/* ]] && [[ "$lib_path" != /usr/lib64/* ]] && \
               [[ "$lib_path" != /usr/local/lib/* ]]; then
            # Copy non-system libraries
            cp "$lib_path" "lib/$lib_name" 2>/dev/null && echo "Copied: $lib_name" || true
          fi
        done < "$DEPS_FILE"
        rm -f "$DEPS_FILE"
        
        # Update rpath of the executable to use local lib directory
        patchelf --set-rpath '$ORIGIN/lib' "$(basename "$EXE_PATH")" 2>/dev/null || echo "Note: patchelf may not be needed or available"
        
        # Update rpath of all copied libraries to use relative paths
        find lib -name "*.so*" -type f -exec patchelf --set-rpath '$ORIGIN' {} \; 2>/dev/null || true
        
        echo "Deployment complete. Summary:"
        echo "Libraries in lib/:"
        ls -lh lib/ | head -20
        echo "Plugins:"
        ls -d plugins/*/ 2>/dev/null | head -10 || echo "No plugin directories"
    
    - name: Create AppImage
      id: create_appimage
      run: |
        VERSION="${GITHUB_REF#refs/tags/}"
        if [ -z "$VERSION" ] || [ "$VERSION" == "$GITHUB_REF" ]; then
          VERSION="dev"
        fi
        EXE_PATH="${{ steps.find_exe.outputs.exe_path }}"
        EXE_DIR="${{ steps.find_exe.outputs.exe_dir }}"
        QT_BASE="${{ steps.qt_path.outputs.qt_base }}"
        APP_NAME="TypistPrison"
        APPIMAGE_NAME="${APP_NAME}-${VERSION}-x86_64.AppImage"
        
        echo "Creating AppImage: $APPIMAGE_NAME"
        echo "Executable path: $EXE_PATH"
        echo "Executable dir: $EXE_DIR"
        
        # Change to build directory first
        cd typistprison/build-release
        
        # Convert paths to relative after changing directory
        # EXE_PATH and EXE_DIR are relative to workspace root, so remove the prefix
        EXE_PATH_REL="${EXE_PATH#typistprison/build-release/}"
        EXE_DIR_REL="${EXE_DIR#typistprison/build-release/}"
        
        # If the paths don't start with the prefix, they might already be relative or absolute
        if [ "$EXE_PATH_REL" == "$EXE_PATH" ]; then
          # Try to find the executable in current directory
          EXE_NAME=$(basename "$EXE_PATH")
          EXE_PATH_REL=$(find . -name "$EXE_NAME" -type f -executable 2>/dev/null | head -1)
          if [ -z "$EXE_PATH_REL" ]; then
            EXE_PATH_REL="$EXE_NAME"
          fi
          EXE_DIR_REL="."
        fi
        
        echo "Relative executable path: $EXE_PATH_REL"
        echo "Relative executable dir: $EXE_DIR_REL"
        
        # Verify executable exists
        if [ ! -f "$EXE_PATH_REL" ]; then
          echo "ERROR: Executable not found at: $EXE_PATH_REL"
          echo "Current directory: $(pwd)"
          echo "Files in current directory:"
          ls -la
          exit 1
        fi
        
        # Download linuxdeploy tools to build directory
        wget -q -O linuxdeploy-x86_64.AppImage https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
        chmod +x linuxdeploy-x86_64.AppImage
        
        # Download Qt plugin for linuxdeploy
        wget -q -O linuxdeploy-plugin-qt-x86_64.AppImage https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage
        chmod +x linuxdeploy-plugin-qt-x86_64.AppImage
        
        # Download appimagetool
        wget -q -O appimagetool-x86_64.AppImage https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
        chmod +x appimagetool-x86_64.AppImage
        
        # Create AppDir structure (relative to current directory)
        APPDIR="AppDir"
        rm -rf "$APPDIR"
        mkdir -p "$APPDIR/usr/bin"
        mkdir -p "$APPDIR/usr/lib"
        mkdir -p "$APPDIR/usr/share/applications"
        mkdir -p "$APPDIR/usr/share/icons/hicolor/256x256/apps"
        
        # Copy executable
        cp "$EXE_PATH_REL" "$APPDIR/usr/bin/$APP_NAME"
        chmod +x "$APPDIR/usr/bin/$APP_NAME"
        
        # Ensure applications directory exists
        mkdir -p "$APPDIR/usr/share/applications"
        
        # Create .desktop file with all required fields
        DESKTOP_FILE="$APPDIR/usr/share/applications/${APP_NAME}.desktop"
        printf '%s\n' \
          '[Desktop Entry]' \
          'Type=Application' \
          'Name=TypistPrison' \
          'GenericName=Text Editor' \
          'Comment=Typist Prison Application' \
          'Exec=TypistPrison' \
          'Icon=TypistPrison' \
          'Categories=Utility;TextEditor;' \
          'Terminal=false' \
          'StartupNotify=true' \
          > "$DESKTOP_FILE"
        
        # Set proper permissions on desktop file
        chmod 644 "$DESKTOP_FILE"
        
        # Verify desktop file was created
        if [ ! -f "$DESKTOP_FILE" ]; then
          echo "ERROR: Failed to create desktop file!"
          exit 1
        fi
        
        echo "Desktop file created at: $DESKTOP_FILE"
        echo "Desktop file permissions: $(ls -l "$DESKTOP_FILE")"
        cat "$DESKTOP_FILE"
        
        # Ensure icon directory exists
        mkdir -p "$APPDIR/usr/share/icons/hicolor/256x256/apps"
        
        # Copy and resize icon if it exists, otherwise create a proper 256x256 placeholder
        ICON_FILE="$APPDIR/usr/share/icons/hicolor/256x256/apps/${APP_NAME}.png"
        if [ -f "../icons/typrison_icon.png" ]; then
          echo "Found icon file, resizing to exactly 256x256..."
          # Resize icon to exactly 256x256 using ImageMagick
          convert "../icons/typrison_icon.png" -resize 256x256! "$ICON_FILE"
          echo "Icon resized and saved to: $ICON_FILE"
          # Verify icon size
          identify "$ICON_FILE" || echo "Warning: Could not verify icon size"
        else
          echo "Icon file not found, creating 256x256 placeholder..."
          # Create a proper 256x256 transparent PNG using ImageMagick
          convert -size 256x256 xc:none -alpha on "$ICON_FILE" || {
            # Fallback: create using base64 if ImageMagick fails
            echo "ImageMagick failed, using fallback method..."
            # This creates a minimal 1x1 PNG, but we need 256x256
            # For now, create a simple colored square as placeholder
            convert -size 256x256 xc:'#2E7D32' "$ICON_FILE" 2>/dev/null || true
          }
        fi
        
        # Verify icon file exists and has correct size
        if [ ! -f "$ICON_FILE" ]; then
          echo "ERROR: Icon file was not created!"
          exit 1
        fi
        
        # Check icon dimensions
        ICON_SIZE=$(identify -format "%wx%h" "$ICON_FILE" 2>/dev/null || echo "unknown")
        echo "Icon file created at: $ICON_FILE"
        echo "Icon size: $ICON_SIZE"
        if [ "$ICON_SIZE" != "256x256" ] && [ "$ICON_SIZE" != "unknown" ]; then
          echo "Warning: Icon size is $ICON_SIZE, expected 256x256. Resizing..."
          convert "$ICON_FILE" -resize 256x256! "$ICON_FILE"
          ICON_SIZE=$(identify -format "%wx%h" "$ICON_FILE" 2>/dev/null || echo "unknown")
          echo "Icon size after resize: $ICON_SIZE"
        fi
        
        # Copy all dependencies from the deployment directory
        # Check if lib, plugins, translations exist in the executable directory
        if [ -d "$EXE_DIR_REL/lib" ]; then
          cp -r "$EXE_DIR_REL/lib" "$APPDIR/usr/lib/"
        elif [ -d "lib" ]; then
          # Also check current directory
          cp -r "lib" "$APPDIR/usr/lib/"
        fi
        if [ -d "$EXE_DIR_REL/plugins" ]; then
          mkdir -p "$APPDIR/usr/plugins"
          cp -r "$EXE_DIR_REL/plugins"/* "$APPDIR/usr/plugins/"
        elif [ -d "plugins" ]; then
          mkdir -p "$APPDIR/usr/plugins"
          cp -r "plugins"/* "$APPDIR/usr/plugins/" 2>/dev/null || true
        fi
        # Skip copying translations - they're usually not needed and make AppImage huge
        # If your app needs specific translations, copy only those
        # if [ -d "$EXE_DIR_REL/translations" ]; then
        #   mkdir -p "$APPDIR/usr/translations"
        #   # Only copy app-specific translations if any
        #   find "$EXE_DIR_REL/translations" -name "*typistprison*.qm" -exec cp {} "$APPDIR/usr/translations/" \; 2>/dev/null || true
        # fi
        
        # Create AppRun script
        printf '%s\n' \
          '#!/bin/bash' \
          'HERE="$(dirname "$(readlink -f "${0}")")"' \
          'export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"' \
          'export QT_PLUGIN_PATH="${HERE}/usr/plugins:${QT_PLUGIN_PATH}"' \
          'export QML2_IMPORT_PATH="${HERE}/usr/qml:${QML2_IMPORT_PATH}"' \
          'exec "${HERE}/usr/bin/TypistPrison" "$@"' \
          > "$APPDIR/AppRun"
        chmod +x "$APPDIR/AppRun"
        
        # Set up environment for linuxdeploy
        export QMAKE="$QT_BASE/bin/qmake"
        export PATH="$QT_BASE/bin:$PATH"
        export LD_LIBRARY_PATH="$QT_BASE/lib:$LD_LIBRARY_PATH"
        
        # Run linuxdeploy to bundle libraries
        ./linuxdeploy-x86_64.AppImage \
          --appdir="$APPDIR" \
          --executable="$APPDIR/usr/bin/$APP_NAME" \
          --desktop-file="$APPDIR/usr/share/applications/${APP_NAME}.desktop" \
          --icon-file="$APPDIR/usr/share/icons/hicolor/256x256/apps/${APP_NAME}.png" || echo "linuxdeploy base completed"
        
        # Run Qt plugin to bundle Qt libraries
        export QMAKE="$QT_BASE/bin/qmake"
        ./linuxdeploy-plugin-qt-x86_64.AppImage --appdir="$APPDIR" || echo "Qt plugin completed"
        
        # Remove unnecessary translations to reduce AppImage size
        # Qt translations are usually not needed unless your app uses them
        # linuxdeploy may have copied them, so remove after it runs
        if [ -d "$APPDIR/usr/translations" ]; then
          TRANS_COUNT=$(find "$APPDIR/usr/translations" -type f 2>/dev/null | wc -l)
          echo "Removing $TRANS_COUNT unnecessary Qt translation files to reduce AppImage size..."
          rm -rf "$APPDIR/usr/translations"
          echo "Translations removed"
        fi
        
        # Verify AppDir structure before creating AppImage
        echo "Verifying AppDir structure..."
        echo "Desktop file: $APPDIR/usr/share/applications/${APP_NAME}.desktop"
        if [ -f "$APPDIR/usr/share/applications/${APP_NAME}.desktop" ]; then
          echo "Desktop file exists"
          cat "$APPDIR/usr/share/applications/${APP_NAME}.desktop"
        else
          echo "ERROR: Desktop file not found!"
          echo "AppDir structure:"
          find "$APPDIR" -type f | head -20
          exit 1
        fi
        
        echo "Icon file: $APPDIR/usr/share/icons/hicolor/256x256/apps/${APP_NAME}.png"
        ICON_FILE="$APPDIR/usr/share/icons/hicolor/256x256/apps/${APP_NAME}.png"
        if [ ! -f "$ICON_FILE" ]; then
          echo "Warning: Icon file not found, creating 256x256 placeholder..."
          mkdir -p "$APPDIR/usr/share/icons/hicolor/256x256/apps"
          convert -size 256x256 xc:'#2E7D32' "$ICON_FILE" 2>/dev/null || {
            echo "ImageMagick failed, using fallback..."
            # Fallback: create minimal PNG
            echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==" | base64 -d > "$ICON_FILE" 2>/dev/null || true
          }
        fi
        
        # Verify icon is exactly 256x256
        if [ -f "$ICON_FILE" ]; then
          ICON_SIZE=$(identify -format "%wx%h" "$ICON_FILE" 2>/dev/null || echo "unknown")
          echo "Icon size: $ICON_SIZE"
          if [ "$ICON_SIZE" != "256x256" ] && [ "$ICON_SIZE" != "unknown" ]; then
            echo "Resizing icon to exactly 256x256..."
            convert "$ICON_FILE" -resize 256x256! "$ICON_FILE"
            ICON_SIZE=$(identify -format "%wx%h" "$ICON_FILE" 2>/dev/null || echo "unknown")
            echo "Icon size after resize: $ICON_SIZE"
          fi
        fi
        
        echo "Executable: $APPDIR/usr/bin/$APP_NAME"
        if [ ! -f "$APPDIR/usr/bin/$APP_NAME" ]; then
          echo "ERROR: Executable not found!"
          exit 1
        fi
        
        echo "AppRun: $APPDIR/AppRun"
        if [ ! -f "$APPDIR/AppRun" ]; then
          echo "ERROR: AppRun not found!"
          exit 1
        fi
        
        # Final verification before creating AppImage
        echo "Final verification before creating AppImage..."
        DESKTOP_FILE="$APPDIR/usr/share/applications/${APP_NAME}.desktop"
        ICON_FILE="$APPDIR/usr/share/icons/hicolor/256x256/apps/${APP_NAME}.png"
        
        if [ ! -f "$DESKTOP_FILE" ]; then
          echo "ERROR: Desktop file missing at: $DESKTOP_FILE"
          echo "Creating it now..."
          mkdir -p "$(dirname "$DESKTOP_FILE")"
          printf '%s\n' \
            '[Desktop Entry]' \
            'Type=Application' \
            'Name=TypistPrison' \
            'GenericName=Text Editor' \
            'Comment=Typist Prison Application' \
            'Exec=TypistPrison' \
            'Icon=TypistPrison' \
            'Categories=Utility;TextEditor;' \
            'Terminal=false' \
            'StartupNotify=true' \
            > "$DESKTOP_FILE"
          chmod 644 "$DESKTOP_FILE"
        fi
        
        if [ ! -f "$ICON_FILE" ]; then
          echo "ERROR: Icon file missing at: $ICON_FILE"
          echo "Creating 256x256 placeholder..."
          mkdir -p "$(dirname "$ICON_FILE")"
          convert -size 256x256 xc:'#2E7D32' "$ICON_FILE"
        fi
        
        # Verify icon is exactly 256x256
        ICON_SIZE=$(identify -format "%wx%h" "$ICON_FILE" 2>/dev/null || echo "unknown")
        if [ "$ICON_SIZE" != "256x256" ]; then
          echo "Resizing icon from $ICON_SIZE to 256x256..."
          convert "$ICON_FILE" -resize 256x256! "$ICON_FILE"
          ICON_SIZE=$(identify -format "%wx%h" "$ICON_FILE" 2>/dev/null || echo "unknown")
          echo "Icon size after resize: $ICON_SIZE"
        fi
        
        echo "Desktop file: $([ -f "$DESKTOP_FILE" ] && echo 'EXISTS' || echo 'MISSING')"
        echo "Icon file: $([ -f "$ICON_FILE" ] && echo "EXISTS ($ICON_SIZE)" || echo 'MISSING')"
        echo "Executable: $([ -f "$APPDIR/usr/bin/$APP_NAME" ] && echo 'EXISTS' || echo 'MISSING')"
        echo "AppRun: $([ -f "$APPDIR/AppRun" ] && echo 'EXISTS' || echo 'MISSING')"
        
        # Create AppImage using appimagetool
        # appimagetool should automatically find the desktop file in usr/share/applications/
        echo "Creating AppImage..."
        ARCH=x86_64 VERSION="$VERSION" ./appimagetool-x86_64.AppImage "$APPDIR" "$APPIMAGE_NAME" 2>&1 || {
          echo "appimagetool with ARCH failed, trying without ARCH and VERSION..."
          ./appimagetool-x86_64.AppImage "$APPDIR" "$APPIMAGE_NAME" 2>&1 || {
            echo "appimagetool failed. Checking critical files..."
            echo "Desktop file exists: $([ -f "$APPDIR/usr/share/applications/${APP_NAME}.desktop" ] && echo 'YES' || echo 'NO')"
            echo "Executable exists: $([ -f "$APPDIR/usr/bin/$APP_NAME" ] && echo 'YES' || echo 'NO')"
            echo "AppRun exists: $([ -f "$APPDIR/AppRun" ] && echo 'YES' || echo 'NO')"
            echo "AppDir size: $(du -sh "$APPDIR" 2>/dev/null | cut -f1)"
            exit 1
          }
        }
        
        # Verify AppImage was created
        if [ ! -f "$APPIMAGE_NAME" ]; then
          echo "ERROR: AppImage was not created!"
          ls -la .
          exit 1
        fi
        
        chmod +x "$APPIMAGE_NAME"
        echo "AppImage created: $APPIMAGE_NAME"
        ls -lh "$APPIMAGE_NAME"
        
        echo "appimage_name=$APPIMAGE_NAME" >> $GITHUB_OUTPUT
        echo "appimage_path=typistprison/build-release/$APPIMAGE_NAME" >> $GITHUB_OUTPUT
    
    - name: Create distributable package
      id: create_package
      run: |
        VERSION="${GITHUB_REF#refs/tags/}"
        if [ -z "$VERSION" ] || [ "$VERSION" == "$GITHUB_REF" ]; then
          VERSION="dev"
        fi
        EXE_PATH="${{ steps.find_exe.outputs.exe_path }}"
        EXE_DIR="${{ steps.find_exe.outputs.exe_dir }}"
        PACKAGE_NAME="TypistPrison-${VERSION}-Linux"
        PACKAGE_DIR="typistprison/build-release/$PACKAGE_NAME"
        
        mkdir -p "$PACKAGE_DIR"
        
        # Verify executable exists before copying
        if [ -z "$EXE_PATH" ] || [ ! -f "$EXE_PATH" ]; then
          echo "ERROR: Executable not found at: $EXE_PATH"
          exit 1
        fi
        
        # Copy everything from the executable directory (including lib, plugins, etc.)
        cp -r "$EXE_DIR"/* "$PACKAGE_DIR/" 2>/dev/null || true
        
        # Ensure executable is in the package
        EXE_NAME=$(basename "$EXE_PATH")
        if [ ! -f "$PACKAGE_DIR/$EXE_NAME" ]; then
          cp "$EXE_PATH" "$PACKAGE_DIR/"
        fi
        chmod +x "$PACKAGE_DIR/$EXE_NAME"
        
        # If executable name is not 'typistprison', create a symlink or rename
        if [ "$EXE_NAME" != "typistprison" ]; then
          ln -sf "$EXE_NAME" "$PACKAGE_DIR/typistprison" || cp "$PACKAGE_DIR/$EXE_NAME" "$PACKAGE_DIR/typistprison"
          chmod +x "$PACKAGE_DIR/typistprison"
        fi
        
        # Create a run script that sets up the environment
        {
          echo '#!/bin/bash'
          echo 'SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"'
          echo 'export LD_LIBRARY_PATH="$SCRIPT_DIR/lib:$LD_LIBRARY_PATH"'
          echo 'export QT_PLUGIN_PATH="$SCRIPT_DIR/plugins:$QT_PLUGIN_PATH"'
          echo 'export QML2_IMPORT_PATH="$SCRIPT_DIR/qml:$QML2_IMPORT_PATH"'
          echo '"$SCRIPT_DIR/typistprison" "$@"'
        } > "$PACKAGE_DIR/run.sh"
        chmod +x "$PACKAGE_DIR/run.sh"
        
        # Create README
        {
          echo "TypistPrison ${VERSION} for Linux"
          echo ""
          echo "This package includes all required Qt dependencies."
          echo ""
          echo "To run:"
          echo "  ./run.sh"
          echo ""
          echo "Or directly:"
          echo "  export LD_LIBRARY_PATH=./lib:\$LD_LIBRARY_PATH"
          echo "  export QT_PLUGIN_PATH=./plugins:\$QT_PLUGIN_PATH"
          echo "  ./typistprison"
        } > "$PACKAGE_DIR/README.txt"
        
        # Create tarball
        cd typistprison/build-release
        tar -czf "${PACKAGE_NAME}.tar.gz" "$PACKAGE_NAME"
        
        echo "package_name=${PACKAGE_NAME}.tar.gz" >> $GITHUB_OUTPUT
        echo "package_path=typistprison/build-release/${PACKAGE_NAME}.tar.gz" >> $GITHUB_OUTPUT
    
    - name: Upload Linux package artifact
      uses: actions/upload-artifact@v4
      with:
        name: linux-app
        path: |
          ${{ steps.create_package.outputs.package_path }}
          ${{ steps.create_appimage.outputs.appimage_path }}
    
    - name: Debug Linux release upload
      if: github.event_name == 'release'
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Release upload URL: ${{ github.event.release.upload_url }}"
        echo "Package path: ${{ steps.create_package.outputs.package_path }}"
        echo "Package name: ${{ steps.create_package.outputs.package_name }}"
        if [ -f "${{ steps.create_package.outputs.package_path }}" ]; then
          echo "Package file exists!"
          ls -lh "${{ steps.create_package.outputs.package_path }}"
        else
          echo "ERROR: Package file not found!"
        fi
    
    - name: Upload package to release
      if: steps.create_package.outputs.package_path != ''
      continue-on-error: false
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url || needs.create-release.outputs.upload_url }}
        asset_path: ${{ steps.create_package.outputs.package_path }}
        asset_name: ${{ steps.create_package.outputs.package_name }}
        asset_content_type: application/octet-stream
    
    - name: Upload AppImage to release
      if: steps.create_appimage.outputs.appimage_path != ''
      continue-on-error: false
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url || needs.create-release.outputs.upload_url }}
        asset_path: ${{ steps.create_appimage.outputs.appimage_path }}
        asset_name: ${{ steps.create_appimage.outputs.appimage_name }}
        asset_content_type: application/octet-stream